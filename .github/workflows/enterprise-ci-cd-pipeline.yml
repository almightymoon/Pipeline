name: 🚀 Enterprise CI/CD Pipeline - Secure Software Supply Chain

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production

env:
  REGISTRY: harbor.yourcompany.com
  IMAGE_NAME: ${{ github.repository }}
  KUBERNETES_NAMESPACE: ml-pipeline
  SONARQUBE_URL: ${{ secrets.SONARQUBE_URL }}
  JIRA_URL: ${{ secrets.JIRA_URL }}
  VAULT_URL: ${{ secrets.VAULT_URL }}

jobs:
  # ==========================================
  # 1. VALIDATE COMMIT STAGE
  # ==========================================
  validate-commit:
    name: 🔍 Validate Commit & Generate Changelog
    runs-on: ubuntu-latest
    outputs:
      commit-valid: ${{ steps.validate.outputs.valid }}
      changelog: ${{ steps.changelog.outputs.content }}
    
    steps:
    - name: 📥 Checkout Code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: 🔐 Validate Commit Signature
      id: validate
      run: |
        echo "Validating commit signatures..."
        if git verify-commit HEAD; then
          echo "valid=true" >> $GITHUB_OUTPUT
          echo "✅ Commit signature valid"
        else
          echo "valid=false" >> $GITHUB_OUTPUT
          echo "❌ Commit signature invalid"
        fi
    
    - name: 📝 Generate Changelog
      id: changelog
      uses: release-drafter/release-drafter@v6
      with:
        config-name: release-drafter.yml
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    
    - name: 🎫 Create Jira Issue (Pipeline Started)
      if: github.event_name == 'push'
      uses: atlassian/gajira-create@v3
      with:
        project: ${{ secrets.JIRA_PROJECT_KEY }}
        issuetype: Task
        summary: "Pipeline Started: ${{ github.ref_name }}"
        description: |
          🚀 **CI/CD Pipeline Started**
          
          **Branch:** ${{ github.ref_name }}
          **Commit:** ${{ github.sha }}
          **Author:** ${{ github.actor }}
          **Repository:** ${{ github.repository }}
          
          **Changelog:**
          ${{ steps.changelog.outputs.content }}
        fields: '{"priority": {"name": "Low"}}'

  # ==========================================
  # 2. BUILD STAGE
  # ==========================================
  build:
    name: 🏗️ Build & Package
    runs-on: ubuntu-latest
    needs: validate-commit
    if: needs.validate-commit.outputs.commit-valid == 'true'
    
    steps:
    - name: 📥 Checkout Code
      uses: actions/checkout@v4
    
    - name: 🐳 Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: 🔐 Login to Harbor Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ secrets.HARBOR_USERNAME }}
        password: ${{ secrets.HARBOR_PASSWORD }}
    
    - name: 🏗️ Build Multi-Arch Images
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: true
        tags: |
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          BUILD_DATE=${{ github.event.head_commit.timestamp }}
          VCS_REF=${{ github.sha }}
          VERSION=${{ github.ref_name }}
    
    - name: 📦 Generate SBOM
      uses: anchore/sbom-action@v0
      with:
        path: .
        format: spdx-json
        output-file: sbom.spdx.json
    
    - name: 📤 Upload SBOM to Nexus
      uses: actions/upload-artifact@v4
      with:
        name: sbom-${{ github.sha }}
        path: sbom.spdx.json

  # ==========================================
  # 3. SAST/SCA SECURITY STAGE
  # ==========================================
  security-scan:
    name: 🔒 Security Analysis (SAST/SCA)
    runs-on: ubuntu-latest
    needs: [validate-commit, build]
    if: needs.validate-commit.outputs.commit-valid == 'true'
    
    steps:
    - name: 📥 Checkout Code
      uses: actions/checkout@v4
    
    - name: 🔍 Run SonarQube Analysis
      uses: sonarqube-quality-gate-action@v2
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        SONAR_TOKEN: ${{ secrets.SONARQUBE_TOKEN }}
      with:
        scanMetadataReportFile: target/sonar/report-task.txt
        args: >
          -Dsonar.projectKey=${{ github.repository }}
          -Dsonar.organization=${{ secrets.SONARQUBE_ORG }}
          -Dsonar.host.url=${{ env.SONARQUBE_URL }}
          -Dsonar.python.coverage.reportPaths=coverage.xml
          -Dsonar.coverage.jacoco.xmlReportPaths=target/site/jacoco/jacoco.xml
    
    - name: 🧪 Run Dependency Check
      uses: dependency-check/Dependency-Check_Action@main
      with:
        project: '${{ github.repository }}'
        path: '.'
        format: 'ALL'
        out: './reports'
    
    - name: 🛡️ Run Trivy Vulnerability Scanner
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-results.sarif'
    
    - name: 📤 Upload Trivy Results to GitHub Security
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: 'trivy-results.sarif'
    
    - name: 📊 Upload Security Reports to DefectDojo
      uses: actions/upload-artifact@v4
      with:
        name: security-reports-${{ github.sha }}
        path: |
          reports/
          trivy-results.sarif
        retention-days: 30

  # ==========================================
  # 4. PUBLISH STAGE
  # ==========================================
  publish:
    name: 📤 Publish Artifacts
    runs-on: ubuntu-latest
    needs: [build, security-scan]
    if: always() && needs.build.result == 'success' && needs.security-scan.result == 'success'
    
    steps:
    - name: 📥 Download SBOM
      uses: actions/download-artifact@v4
      with:
        name: sbom-${{ github.sha }}
        path: ./artifacts
    
    - name: 📤 Publish to Nexus Repository
      uses: actions/upload-artifact@v4
      with:
        name: application-artifacts-${{ github.sha }}
        path: |
          artifacts/
        retention-days: 90
    
    - name: 🏷️ Tag Release
      if: github.ref == 'refs/heads/main'
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: v${{ github.run_number }}
        release_name: Release v${{ github.run_number }}
        body: |
          ## 🚀 Release v${{ github.run_number }}
          
          **Commit:** ${{ github.sha }}
          **Build:** ${{ github.run_number }}
          
          ### 📦 Artifacts
          - Docker Images: `${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}`
          - SBOM: Available in artifacts
          
          ### 🔒 Security
          - SonarQube Quality Gate: ✅ Passed
          - Vulnerability Scan: ✅ Completed
          - Dependency Check: ✅ Completed
        draft: false
        prerelease: false

  # ==========================================
  # 5. DEPLOY STAGE
  # ==========================================
  deploy:
    name: 🚀 Deploy to Kubernetes
    runs-on: ubuntu-latest
    needs: [build, security-scan, publish]
    if: always() && needs.build.result == 'success' && needs.security-scan.result == 'success'
    environment: ${{ github.event.inputs.environment || 'staging' }}
    
    steps:
    - name: 📥 Checkout Code
      uses: actions/checkout@v4
    
    - name: ☸️ Setup Kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'
    
    - name: 🔐 Configure Kubernetes Access
      run: |
        echo "${{ secrets.KUBECONFIG }}" | base64 -d > kubeconfig
        export KUBECONFIG=kubeconfig
    
    - name: 🔑 Retrieve Secrets from Vault
      uses: hashicorp/vault-action@v2
      with:
        url: ${{ env.VAULT_URL }}
        token: ${{ secrets.VAULT_TOKEN }}
        secrets: |
          secret/kubernetes/${{ github.event.inputs.environment || 'staging' }} config
          secret/application/${{ github.repository }} app-config
    
    - name: 🏗️ Deploy with Helm
      uses: azure/setup-helm@v3
      with:
        version: 'latest'
    
    - name: 📦 Package Helm Chart
      run: |
        helm package ./charts/ml-pipeline
        helm repo index .
    
    - name: 🚀 Deploy to Kubernetes
      run: |
        helm upgrade --install ml-pipeline-${{ github.run_number }} \
          ./charts/ml-pipeline \
          --namespace ${{ env.KUBERNETES_NAMESPACE }} \
          --create-namespace \
          --set image.repository=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} \
          --set image.tag=${{ github.sha }} \
          --set environment=${{ github.event.inputs.environment || 'staging' }} \
          --set vault.secretPath=secret/kubernetes/${{ github.event.inputs.environment || 'staging' }} \
          --wait \
          --timeout 10m
    
    - name: ✅ Verify Deployment
      run: |
        kubectl get pods -n ${{ env.KUBERNETES_NAMESPACE }} -l app=ml-pipeline
        kubectl get services -n ${{ env.KUBERNETES_NAMESPACE }}
        kubectl get ingress -n ${{ env.KUBERNETES_NAMESPACE }}

  # ==========================================
  # 6. TEST STAGE
  # ==========================================
  test:
    name: 🧪 Automated Testing
    runs-on: ubuntu-latest
    needs: deploy
    if: needs.deploy.result == 'success'
    
    steps:
    - name: 📥 Checkout Code
      uses: actions/checkout@v4
    
    - name: 🐍 Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: 📦 Install Dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-cov pytest-xdist
    
    - name: 🧪 Run Unit Tests
      run: |
        pytest tests/ \
          --cov=src/ \
          --cov-report=xml \
          --cov-report=html \
          --junitxml=test-results.xml \
          --maxfail=5 \
          -v
    
    - name: 🧪 Run Integration Tests
      run: |
        pytest tests/integration/ \
          --junitxml=integration-test-results.xml \
          -v
    
    - name: 📊 Upload Test Results to ReportPortal
      uses: actions/upload-artifact@v4
      with:
        name: test-results-${{ github.sha }}
        path: |
          test-results.xml
          integration-test-results.xml
          coverage.xml
          htmlcov/
        retention-days: 30
    
    - name: 🎫 Create Jira Issue for Test Failures
      if: failure()
      uses: atlassian/gajira-create@v3
      with:
        project: ${{ secrets.JIRA_PROJECT_KEY }}
        issuetype: Bug
        summary: "Test Failure in Pipeline #${{ github.run_number }}"
        description: |
          🐛 **Test Failure Detected**
          
          **Pipeline:** #${{ github.run_number }}
          **Branch:** ${{ github.ref_name }}
          **Commit:** ${{ github.sha }}
          
          **Test Results:** See artifacts for detailed reports
          **Build Log:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        fields: '{"priority": {"name": "High"}}'

  # ==========================================
  # 7. QA STAGE
  # ==========================================
  qa:
    name: 🔍 Quality Assurance Testing
    runs-on: ubuntu-latest
    needs: [deploy, test]
    if: needs.deploy.result == 'success' && needs.test.result == 'success'
    
    steps:
    - name: 📥 Checkout Code
      uses: actions/checkout@v4
    
    - name: 🌐 Setup Playwright
      uses: microsoft/playwright-github-action@v1
    
    - name: 🔍 Run E2E Tests
      run: |
        npx playwright test \
          --reporter=html,junit \
          --output-dir=playwright-report
    
    - name: 📊 Upload QA Results to ReportPortal
      uses: actions/upload-artifact@v4
      with:
        name: qa-results-${{ github.sha }}
        path: |
          playwright-report/
        retention-days: 30
    
    - name: 🎫 Create Jira Issue for QA Failures
      if: failure()
      uses: atlassian/gajira-create@v3
      with:
        project: ${{ secrets.JIRA_PROJECT_KEY }}
        issuetype: Bug
        summary: "QA Test Failure in Pipeline #${{ github.run_number }}"
        description: |
          🔍 **QA Test Failure Detected**
          
          **Pipeline:** #${{ github.run_number }}
          **Environment:** ${{ github.event.inputs.environment || 'staging' }}
          
          **QA Results:** See artifacts for detailed reports
        fields: '{"priority": {"name": "Medium"}}'

  # ==========================================
  # 8. PERFORMANCE TESTING STAGE
  # ==========================================
  performance:
    name: ⚡ Performance Testing
    runs-on: ubuntu-latest
    needs: [deploy, qa]
    if: needs.deploy.result == 'success' && needs.qa.result == 'success'
    
    steps:
    - name: 📥 Checkout Code
      uses: actions/checkout@v4
    
    - name: ⚡ Run K6 Performance Tests
      uses: grafana/k6-action@v0.3.1
      with:
        filename: tests/performance/load-test.js
    
    - name: 📊 Run Artillery Load Tests
      run: |
        npm install -g artillery
        artillery run tests/performance/artillery-config.yml \
          --output artillery-report.json \
          --output artillery-report.html
    
    - name: 📊 Upload Performance Results to ReportPortal
      uses: actions/upload-artifact@v4
      with:
        name: performance-results-${{ github.sha }}
        path: |
          artillery-report.json
          artillery-report.html
        retention-days: 30

  # ==========================================
  # 9. MONITORING & REPORTING
  # ==========================================
  monitoring:
    name: 📊 Setup Monitoring & Reporting
    runs-on: ubuntu-latest
    needs: [deploy, test, qa, performance]
    if: always()
    
    steps:
    - name: 📊 Send Metrics to Prometheus
      run: |
        curl -X POST "${{ secrets.PROMETHEUS_PUSHGATEWAY_URL }}/metrics/job/pipeline" \
          -H "Content-Type: text/plain" \
          --data-binary @- <<EOF
        pipeline_run_total{status="success",branch="${{ github.ref_name }}"} 1
        pipeline_duration_seconds{branch="${{ github.ref_name }}"} ${{ job.duration }}
        pipeline_tests_passed{branch="${{ github.ref_name }}"} ${{ needs.test.result == 'success' && '1' || '0' }}
        pipeline_tests_failed{branch="${{ github.ref_name }}"} ${{ needs.test.result == 'failure' && '1' || '0' }}
        EOF
    
    - name: 🎫 Update Jira Issue (Pipeline Completion)
      if: always()
      uses: atlassian/gajira-transition@v3
      with:
        issue: ${{ steps.jira-issue.outputs.issue }}
        transition: Done
        comment: |
          🎉 **Pipeline Completed**
          
          **Status:** ${{ job.status }}
          **Duration:** ${{ job.duration }}
          
          **Results:**
          - ✅ Build: ${{ needs.build.result }}
          - 🔒 Security: ${{ needs.security-scan.result }}
          - 🧪 Tests: ${{ needs.test.result }}
          - 🔍 QA: ${{ needs.qa.result }}
          - ⚡ Performance: ${{ needs.performance.result }}
          
          **Artifacts:** Available in GitHub Actions
          **Monitoring:** Prometheus metrics updated

  # ==========================================
  # 10. CLEANUP & NOTIFICATIONS
  # ==========================================
  cleanup:
    name: 🧹 Cleanup & Notifications
    runs-on: ubuntu-latest
    needs: [monitoring]
    if: always()
    
    steps:
    - name: 🧹 Cleanup Old Artifacts
      run: |
        echo "Cleaning up old pipeline artifacts..."
        # Keep only last 10 successful builds
        # This would typically be done via API calls
    
    - name: 📧 Send Notification
      if: always()
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ job.status }}
        channel: '#ci-cd'
        text: |
          🚀 **Pipeline ${{ job.status }}** - ${{ github.repository }}
          
          **Branch:** ${{ github.ref_name }}
          **Commit:** ${{ github.sha }}
          **Environment:** ${{ github.event.inputs.environment || 'staging' }}
          
          **Results:**
          - Build: ${{ needs.build.result }}
          - Security: ${{ needs.security-scan.result }}
          - Tests: ${{ needs.test.result }}
          - QA: ${{ needs.qa.result }}
          - Performance: ${{ needs.performance.result }}
          
          **View:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # ==========================================
  # 11. SECURITY & COMPLIANCE
  # ==========================================
  security-compliance:
    name: 🛡️ Security & Compliance Check
    runs-on: ubuntu-latest
    needs: [security-scan]
    if: needs.security-scan.result == 'success'
    
    steps:
    - name: 🔍 Run in-toto Supply Chain Verification
      run: |
        pip install in-toto
        # Verify supply chain integrity
        in-toto-verify \
          --layout layout.json \
          --layout-key layout-key.pub
    
    - name: 📋 Generate Compliance Report
      run: |
        echo "Generating compliance report..."
        # Generate compliance report for audit
    
    - name: 🎫 Create Critical Security Issue
      if: failure()
      uses: atlassian/gajira-create@v3
      with:
        project: ${{ secrets.JIRA_PROJECT_KEY }}
        issuetype: Task
        summary: "🚨 CRITICAL: Security Compliance Failure"
        description: |
          🚨 **CRITICAL SECURITY ISSUE**
          
          **Pipeline:** #${{ github.run_number }}
          **Issue:** Supply chain verification failed
          
          **Immediate Action Required**
        fields: '{"priority": {"name": "Critical"}}'
